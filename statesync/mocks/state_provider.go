// Code generated by mockery. DO NOT EDIT.
package mocks

import (
	context "context"
	state "github.com/baron-chain/cometbft-bc/state"
	mock "github.com/stretchr/testify/mock"
	types "github.com/baron-chain/cometbft-bc/types"
	pqc "github.com/baron-chain/cometbft-bc/crypto/pqc"
)

// StateProvider is an autogenerated mock type for the StateProvider type
type StateProvider struct {
	mock.Mock
	aiOptimizer   AIOptimizer
	pqcVerifier   PQCVerifier
}

// AIOptimizer represents the AI optimization interface
type AIOptimizer interface {
	OptimizeStateAccess(height uint64) float64
	PredictNextState(height uint64) uint64
}

// PQCVerifier represents the quantum-safe verification interface
type PQCVerifier interface {
	VerifyStateSignature(state []byte, signature []byte) bool
	SignState(state []byte) []byte
}

// AppHash provides a mock function with given fields: ctx, height
func (_m *StateProvider) AppHash(ctx context.Context, height uint64) ([]byte, error) {
	// AI optimization for state access
	if _m.aiOptimizer != nil {
		_m.aiOptimizer.OptimizeStateAccess(height)
	}

	ret := _m.Called(ctx, height)
	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, uint64) []byte); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	// Add PQC signature to hash if verifier is available
	if _m.pqcVerifier != nil {
		r0 = _m.pqcVerifier.SignState(r0)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Commit provides a mock function with given fields: ctx, height
func (_m *StateProvider) Commit(ctx context.Context, height uint64) (*types.Commit, error) {
	// AI optimization for commit access
	if _m.aiOptimizer != nil {
		_m.aiOptimizer.OptimizeStateAccess(height)
	}

	ret := _m.Called(ctx, height)
	var r0 *types.Commit
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.Commit); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			commit := ret.Get(0).(*types.Commit)
			// Add PQC signature to commit if verifier is available
			if _m.pqcVerifier != nil {
				commit = _m.addPQCSignatureToCommit(commit)
			}
			r0 = commit
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// State provides a mock function with given fields: ctx, height
func (_m *StateProvider) State(ctx context.Context, height uint64) (state.State, error) {
	// AI optimization for state access
	if _m.aiOptimizer != nil {
		_m.aiOptimizer.OptimizeStateAccess(height)
		nextHeight := _m.aiOptimizer.PredictNextState(height)
		// Prefetch predicted next state
		go _m.prefetchState(ctx, nextHeight)
	}

	ret := _m.Called(ctx, height)
	var r0 state.State
	if rf, ok := ret.Get(0).(func(context.Context, uint64) state.State); ok {
		r0 = rf(ctx, height)
	} else {
		r0 = ret.Get(0).(state.State)
		// Add PQC signatures to state if verifier is available
		if _m.pqcVerifier != nil {
			r0 = _m.addPQCSignatureToState(r0)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Helper methods for PQC and AI features

// addPQCSignatureToCommit adds quantum-safe signatures to commit
func (_m *StateProvider) addPQCSignatureToCommit(commit *types.Commit) *types.Commit {
	if commit == nil || _m.pqcVerifier == nil {
		return commit
	}
	
	// Sign commit data with PQC
	signature := _m.pqcVerifier.SignState(commit.Hash())
	commit.Signatures = append(commit.Signatures, pqc.NewSignature(signature))
	return commit
}

// addPQCSignatureToState adds quantum-safe signatures to state
func (_m *StateProvider) addPQCSignatureToState(s state.State) state.State {
	if _m.pqcVerifier == nil {
		return s
	}
	
	// Sign state data with PQC
	signature := _m.pqcVerifier.SignState(s.Hash())
	s.LastSignature = signature
	return s
}

// prefetchState asynchronously loads predicted next state
func (_m *StateProvider) prefetchState(ctx context.Context, height uint64) {
	_m.Called(ctx, height)
}

// EnableAIOptimization enables AI features with the provided optimizer
func (_m *StateProvider) EnableAIOptimization(optimizer AIOptimizer) {
	_m.aiOptimizer = optimizer
}

// EnablePQC enables quantum-safe features with the provided verifier
func (_m *StateProvider) EnablePQC(verifier PQCVerifier) {
	_m.pqcVerifier = verifier
}

type mockConstructorTestingTNewStateProvider interface {
	mock.TestingT
	Cleanup(func())
}

// NewStateProvider creates a new instance of StateProvider with optional PQC and AI features
func NewStateProvider(t mockConstructorTestingTNewStateProvider) *StateProvider {
	mock := &StateProvider{}
	mock.Mock.Test(t)
	t.Cleanup(func() { mock.AssertExpectations(t) })
	return mock
}

// NewStateProviderWithFeatures creates a new instance with PQC and AI features enabled
func NewStateProviderWithFeatures(t mockConstructorTestingTNewStateProvider, 
    aiOptimizer AIOptimizer, pqcVerifier PQCVerifier) *StateProvider {
	provider := NewStateProvider(t)
	provider.aiOptimizer = aiOptimizer
	provider.pqcVerifier = pqcVerifier
	return provider
}
